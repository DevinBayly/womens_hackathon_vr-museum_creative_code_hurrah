<html>

<head>
    <!-- this imports the aframe package that we use for web vr -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.js"></script>
</head>

<body>
    <script>

        AFRAME.registerComponent("anchor-reader", {
            schema: {
                // accept our input as the name of the empty from the blender file that we used to more intuitively position the info and movement icons
                anchorName: { type: "string" },
            },
            init: function () {
                // this is the function that we will use to update the location of the child
                var match_name = function () {
                    var mesh = this.el.getObject3D("mesh") // might need to specify the name actually
                    console.log("this mesh is the one we loaded", mesh)
                    // can search the children for a name matching anchorName
                    // then get the circle within the entity and set the rotation and translation on that
                    let infoCircle = this.el.children[0]
                    let success = false
                    for (let anchor of mesh.children) {
                        console.log(anchor.name)
                        if (anchor.name == this.data.anchorName) {
                            // unfortunate change of how values are handled between blender's zup and threejs y up
                            // because we switched systems we have to invert the x, and then change which is z vs y, and then make the rotation use y instead of z, the same kinds of inversions are probably used if needing to handle other kinds of rotation, but for eye level info buttons this should be enough
                            infoCircle.object3D.position.copy(anchor.position)
                            infoCircle.object3D.rotation.copy(anchor.rotation)
                            success = true
                        }
                    }
                    if (!success) {
                        // should probably delete, not enough empties for number of sketches
                        console.log("no match for ", this.data.anchorName)
                        this.el.remove()
                    }
                }
                match_name = match_name.bind(this)
                // here we iterate over the model if it's finished loading and then introduce
                this.el.addEventListener("model-loaded", match_name)
            },
        });
        AFRAME.registerComponent('draw-canvas', {
            schema: { default: '' },

            init: function () {
                let updater = () => {

                    this.canvas = document.getElementById("defaultCanvas0");
                    if (this.canvas) {
                        console.log("yes found canvas", canvas)
                    }
                }
                updater.bind(this)
                setTimeout(updater, 5000)
            },
            tick: function () {

                //     // thanks to https://github.com/aframevr/aframe/issues/3936 for the update fix
                let material = this.el.getObject3D('mesh').material;
                if (!material.map)
                    return;
                else
                    material.map.needsUpdate = true;
            }
        });
        AFRAME.registerComponent("sketchlistener", {
            schema: {
                vid: { type: "int" },
                thumburl: { type: "string" },
            },
            init: function () {
                // simplify reference to the entity in code
                let el = this.el;
                // the input provided by the component defined on the entity
                // callbacks setup to handle behavior from different mousing interactions
                let thumburl = this.data.thumburl
                let vid = this.data.vid


                el.setAttribute("material", `shader:flat;src:${thumburl}`)
                this.el.addEventListener("mouseenter", function (e) {
                    // play with emissivity
                    el.setAttribute("material", "color", "#5ef7ff");
                    //el.setAttribute("material","emissiveIntensity","1")
                });
                this.el.addEventListener("mouseleave", function () {
                    //el.setAttribute("material", "emissiveIntensity",'.2')
                    el.setAttribute("material", "color", "white");
                });
                // this is if the html file was what was put in
                //
                this.el.addEventListener("click", function () {
                    // create a canvas, run the code, and replace the shader src with the canvas
                    //TODO decide what happens when a different sketch is activated, do we see the other one shut off?
                    let canvas = document.querySelector("#my-canvas")
                    let script = document.querySelector("#code")
                    // go get the code
                    fetch(`https://openprocessing.org/api/sketch/${vid}/code`).then(res => res.json()).then(codej => {
                       script.onload = ()=> {
                        console.log("starting the p5 script")
                       }
                       script.text = codej[0].code 
                    })


                });
            },
        });
        AFRAME.registerComponent("kickoff", {
            init: function () {
                let el = this.el

                fetch("https://openprocessing.org/api/curation/87642/sketches?limit=10&offset=0").then(res => res.json()).then(j => {


                    let scene = this.el
                    // iterate over indices of the anchors
                    let i = 0
                    for (let sketch of j) {
                        // get the sketch id
                        let vid = sketch.visualID
                        let thumbURLHash = sketch.thumbnailUpdatedOn.replace(/\D/g, "")
                        let thumbURL = `https://openprocessing-usercontent.s3.amazonaws.com/thumbnails/visualThumbnail${vid}@2x.jpg?hash=${thumbURLHash}`
                        let anchorreader = document.createElement("a-entity")
                        let childgeometry = document.createElement("a-entity")
                        anchorreader.append(childgeometry)
                        scene.append(anchorreader)
                        anchorreader.setAttribute("anchor-reader", `anchorName:piece${i}`)
                        anchorreader.setAttribute("gltf-model", "#anchors")
                        // increment i
                        i += 1
                        childgeometry.setAttribute("geometry", "primitive:plane")
                        // j is usually a list in case there's more than a single file, for our sake though we assume that single files are being used
                        childgeometry.setAttribute("sketchlistener", `vid:${vid};thumburl:${thumbURL}`)



                    }

                })
            }
        })
    </script>
    <script id="code"></script>
    <script>
    </script>
    <a-scene kickoff id="#scene" loading-screen="dotsColor: black; backgroundColor: white" cursor="rayOrigin: mouse">
        <a-assets>
            <!-- TODO change default size of the canvas -->
            <canvas id="my-canvas" crossorigin="anonymous" width="512" height="512"></canvas>
            <a-asset-item id="museum" src="museum.glb"></a-asset-item>
            <a-asset-item id="anchors" src="anchors.glb"></a-asset-item>
        </a-assets>
        <a-entity gltf-model="#museum" material="side:double;shader:flat"></a-entity>
    </a-scene>

</body>

</html>